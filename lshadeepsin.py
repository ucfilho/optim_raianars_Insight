# -*- coding: utf-8 -*-
"""LShadeEpSin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z4Xa_e57H06AMQEykcs95ICTGp897GFA
"""

import numpy as np
import scipy.stats
import random

def de(MAX,MIN,gen,popsize,fobj,X,fitness,method,SF,mi_F,SCR,mi_CR):
  # you need to return to main code 
  #       return X,BEST,FOBEST,XY,BEST_XY,SF,SCR,SFreq,miF,miCR,miFreq
  # main code need to define before change generations 
  #    
  # SF = np.asarray([0.5]); SCR = np.asarray([0.5]); SFreq=np.asarray([1.0])
  # miF = np.asarray([0.5]); miCR = np.asarray([0.5])
  # NPmax= 18*dim;NP=NPmax;
  # method = NPmax,NPmin,maxFES,FES
  # tuneEVAL= [NP,FES,gen] # to update results main code
  #         use in main code: popsize, FES, gen = tuneEVAL
  
  p = 0.1; c = 0.1; H = 5;frq = 1.0;# frq = 1???
  NPmax,NPmin,maxFES,FES = method
  dim = len(X[0,:])
  best_idx = np.argmin(fitness) # not using the best anymore but a random best
  best = X[best_idx]
  fbest = fitness[best_idx]
  Gmax =1000 #?

  if(NP >= NPmin):
    
    mi_F_gen = random.choice(mi_F)
    mi_CR_gen = random.choice(mi_CR)
    freq = scipy.stats.cauchy.rvs(loc=mi_F_gen, scale=0.1, size=popsize)
    freq =  np.clip(freq, 1.0, 3.0)
    CR_values = np.random.normal(mi_CR_gen , 0.1,popsize )

    F_values = []
    if(FES <= 0.5*maxFES):
      for i in range(popsize):
        rnd= np.random.uniform()
        if(rnd < 0.5):
          Fig = 0.5*(np.sin(2*np.pi*freq[i]*gen+np.pi)*(Gmax-gen)/Gmax+1.0)
        else:
          Fig = 0.5*(np.sin(2*np.pi*frq*gen)*(gen+1)/Gmax+1.0)
        F_values.append(Fig)
    else:
      mi_F_gen = random.choice(mi_F)
      F_values= scipy.stats.cauchy.rvs(loc=mi_F_gen, scale=0.1, size=popsize)
      F_values=  np.clip(F, 1.0, 3.0)

    deltaF = np.zeros(popsize)
    for i in range(popsize):
      rnd= np.random.uniform()
      best_number = int(p*popsize*rnd)
      ind =np.argpartition(fitness, -best_number)[-best_number:] # find index of best p*popsize
      best_idx = random.choice(ind) # index of the best in p*popsize*rnd (random best)
      best_selection = X[best_idx]

      mut = F_values[i]
      crossp = CR_values[i]
      idxs = [idx for idx in range(popsize) if idx != j]
      a, b, c = X[np.random.choice(idxs, 3, replace = False)]
      mutant = X[i,:]+mut*(best_selection-X[i,:]) + mut * (b - c)

      rnd= np.random.uniform()

      if(rnd <= crossp):
        for ind in range(dim):
          if(mutant[ind]>MAX[ind]):
            mutant[ind] = MAX[ind]
          if(mutant[ind]<MIN[ind]):
            mutant[ind] = MIN[ind] 
        X[i,:] = np.copy(mutant)
        fnew = fobj(mutant)
        deltaF[i] = np.abs(fnew-fitness[i])
        fitness[i] = fnew
        FES = FES + 1
        SF=np.append(SF,mut)
        SCR=np.append(SCR,crossp)
        SFreq=np.append(SFreq,freq[i])
        
        if(fnew < fbest):
          best = newX
          fbest = fnew

  
    sumF= sum(deltaF)
    if(sumF == 0):
      w =np.ones(popsize)
    else:
      w =  np.asarray([fi/sumF for fi in deltaF])
    
    LehmerSF = np.dot(w,SF*SF)/np.dot(w,SF)
    LehmerSCR = np.dot(w,SCR*SCR)/np.dot(w,SCR)
    LehmerSFreq = np.dot(w,SFreq*SFreq)/np.dot(w,SFreq)
    miF= np.append(miF,LehmerSF)
    miCR= np.append(miCR,LehmerSCR)
    miFreq= np.append(miFreq,LehmerFreq)
    

  if(NP <= NPmin ): # using random walking to conclude
    Xfinal=np.zeros((NP,dim)) # X is Frannk population
    sigma=np.zeros((NP,dim)) 
    FES = FES + 1
    individual = -1

    while(FES < maxFES):
      for k in range(NP):
        individual = individual + 1
        for j in range(dim):
          r=np.random.random()
          test =r*(MAX[j]-MIN[j])+MIN[j]
          valor =(k+1) /(2*NP) *(test -best[k,j])
          sigma= np.cos(np.pi*valor)
          Xfinal[k,j] =  np.random.normal(test , sigma )
        if(FES < maxFES):
          fcalc = fobj(Xfinal[k,:])
          FES = FES + 1
          if(fcalc < fbest):
            best = Xfinal[k,:]
            fbest = fcalc
          if(individual < NP): # exchange population until reach maxFES
            X[individual,:] = np.copy(Xfinal[k,:])
            fitness[individual] =fcalc
          else:
            individual = 0
            X[individual,:] = np.copy(Xfinal[k,:])
            fitness[individual] =fcalc


  y=fitness

  BEST=best
  FOBEST=fbest
  XY= np.c_[X,y] #concatena x e y em 2 colunas            
  XYsorted = XY[XY[:,-1].argsort()] #Ordena a partir da last col(Y) for all row
  XY=XYsorted
  BEST_XY =np.append(BEST,FOBEST)
  calc = (NPmin-NPmax)/maxFES*FES+NPmax # Linear Population Size Reduction (LPSR)
  NP = int(np.round(calc)) # Linear Population Size Reduction (LPSR) 
  gen = gen + 1
  tuneEVAL= [NP,FES,gen]

  return X,BEST,FBEST,XY,BEST_XY,tuneEVAL,SF,SCR,SFreq,miF,miCR,miFreq
